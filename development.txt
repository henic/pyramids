Первое серьезное знакомство с QT. Короткий предыдущий опыт был позитивен, 
но требовал лишь работы с QtCreator как средой IDE и описания класса QString. Несчитово.

Очередная реализация игры, подобной tic-tac-toe (крестики-нолики).
Тот случай, когда путь важнее цели, потому уже, что цель вообще ничего не стоит. 
Интересны здесь набитые шишки и раскладка по времени.

В анамнезе много лет программирования, очень мало с графикой и собственно C++. 
Специфика работы заставляет максимально использовать самый простой C.
 
Начал правильно: с описания того, что хочу видеть в конце разработки. 
Куски, которые можно ваять независимо. Контрольные точки, в которых 
проект можно показать стороннему человеку, и он поймет, что сделано.
Десять часов. 
Совпало процентов на семьдесят.
Разница связана, в основном, с непониманием инструмента, на котором предстояло работать.

Впечатления:
- Qt - это кроссплатформенный MFC, написанный вменяемыми программистами для вменяемых разработчиков. 
Существенно меньший объем без заметной потери возможностей. Бесплатный, опять же.
- Документация великолепна. Книжек мало, нужны они более для ликбеза и получения общей картины, 
что вообще реализовано. 
- Большинство идей уже приходили в голову многим, не менее умным, некоторые выкладывали 
на общее обозрение реализацию.
Какой-то чех вбил в сорок килобайт выполняемого файла графику и сетевую поддержку (на win32 api), 
еще в пятнадцать - прилично играющий алгоритм. С возможностью замены на свой. Застрелиться от зависти.

Главное окно более или менее понятно.
По центру - доска. С боков - информация об игроках, оставшихся фишках, и всякие ненужности.
Внизу - кнопки и строка статуса. 
Кнопки: Start, Stop, Options, Move Now, Takeback. 
Для красоты и ощущения вовлеченности - еще несколько строк, рассказывающих о том, 
какой ход сейчас рассматривается, и каковы его шансы быть принятым.
Наверху - меню, дублирующее кнопки, плюс информация о программе.

Грабли №1. Рисовать можно только в главном треде. Причем, в обработке события paint. 
Когда узнаешь об этом факте, причина очевидна. Но в книжках почему-то не видел, попытки 
попыток разобраться без гугля стоили четырех часов экспериментов.

Грабли №2. Обновление данных в главном окне - аналогичная история. 
Только в главном треде. Поди доберись до него из фонового. 
Была такая же проблема пятнадцать лет назад, как-то решил, с тех пор не заморачивался. 
Посмотрел в старом коде - лучше бы не смотрел, одно расстройство. 
Первая же ссылка в гугле объяснила, что главному окну можно послать сообщение. 
Уточненный поиск - что в Qt можно обойтись интерфейсом сигнал+слот.

Необходимые фичи: 
- возможность скидывать отладочную печать в файл. Есть готовая реализация. 
- сохранение конфигурации.
- функция проверки целостности памяти.

Баловство:
- Возможность менять внешний вид (цвет и форма) фишек.    

Грабли №3. Можно было предположить, что работа с ini-файлами уже реализована. Класс QSettings. 
И зачем было самому пытаться? Тридцать минут работы, но сначала пять часов, убитых на самостоятельную реализацию.

Грабли №4. 
В отличие от MFC (во всяком случае, by default), groupBox - не просто рамка, а контейнер виджетов. Непрозрачный.
Соответственно, нарисовать внутри него - не прохонже, рисунок окажется вторым слоем, под ним.

Грабли №5.
В процессе поймал memory leak. Узнал о существовании функции _heapchk и способах локализации проблемы.
А также о пагубности смешения C и C++.  Абстрактно знаешь, что в C++ структура мало чем отличается от класса.
Но понимаешь только столкнувшись с тем, что у нее есть деструктор, и там освобождается память, 
если руки кривые, может статься, одна и та же дважды. 
Три часа поиска ошибки.

Грабли №6.
qDebug() << convert_to_str(arg2) << convert_to_str(arg1);
Возвращает один и тот же адрес, сам виноват, не надо было возвращать статическую 
переменную, содержащую результат преобразования. Нельзя смешивать, прошлые грабли оказались недостаточны для понимания.


Необходимые классы.
cell. Клетка должна уметь нарисовать себя. Отрапортовать, занята ли фишкой.
board. Доступ к клеткам игрового поля. Их координаты. 
Game. В ее членах - доска и промежуточные данные об игре. История ходов. Список возможных ходов. Рассматриваемый. Лучший из рассмотренных.
Конфигурация. Размер доски, число фишек, их форма и цвет. Кто из игроков - компьютер.
Самый красивый для демонстрации вариант, если оба компьютеры.
Если один, тоже все понятно. А вот два человека, футболящие друг другу мышку, чтобы сделать ход... Теперь понятно, зачем авторы аналогичных программ поддерживают игру через сеть.
Наверное, и клавиатурный интерфейс нужен.
Итак, окно конфигурации...
Ограничиваем ли время хода?
Рисуем ли угрозу (когда ход человека). Подсказку?
Цвет и форма фишек. Имена игроков.
Какие опции исключают друг друга, какие нельзя менять в процессе игры. Зависимости.
Пятнадцать часов, из которых на кодирование - едва ли двадцать процентов. 

Пока компьютер думает, можно развлечь пользователя какой-нибудь ерундой. Например, умной цитатой, вытащенной с внешнего сервера.
http-клиент реализован стандартными средствами.
Два часа.

